---
title: "crudr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{crudr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(crudr)
```


## 

# Overview


This package is a CRUD app. The idea behind `crudr` is to make it easy
for you or your organization to centrally maintain a single source of
golden data while at the same time allowing distributed control of the
data for updates.

## A Common Problem

Each company I have worked for has different departments with different
spreadsheets that track the same information. For instance, let's say
you have a bunch of store locations in your company. Ideally, someone in
your company has all the updated information about those locations, e.g.
the store's mailing address, phone number, email, manager, manager's
email, etc. In most companies, that information actually resides in a
lot of different places and it almost always has errors because managers
move around, store leases expire, and the spreadsheets that you got from
those maintainers become outdated. Further, Joe might be in charge of
the locations, but Sally knows the Manager info, etc. You need that data
to be correct, joined, posted, and available for everyone, at any time
time, but maintaining quality data is hard to do. This package helps to
solve the distributed data updating and distributed data use problem.

## Goals for crudr

The goals with crudr are to:

1.  Present data from a relational database through a Shiny app for
    viewing and management

2.  Separate data viewers from data managers / administrators

3.  Make it easy to control which admin users can update columns in a DB
    table

4.  Keep a record of all changes made to the database table in a
    corresponding change log table

5.  Allow more than one simultaneous editor without crashes

6.  Be database agnostic

### Other Notes

-   Crudr works by synchronizing tables between the User's Computer, the
    Host Server, and your Database
-   The code is built with Shiny modules so that you can manage and
    present several tables in the same app
-   SQLite, Postgres, and Snowflake are the databases that I have tested
-   The database checks periodically whether other admins have made
    changes to the data; if so, the UI and server refresh
-   I would love if someone at RStudio could improve the code or just
    take the code and make it their own. It'd be great if people could
    use this app broadly since this problem exists so often, but I don't
    know how to make it really robust since I'm a novice.

## 

# Getting Started

To install crudr, run:

```{r install-crudr, eval = F}
remotes::install_github('eauleaf/crudr')
```

The Example is built from these packages, so you might want to install
the below packages. Note: the package 'pool' must be the most updated
version on CRAN.

```{r packages, eval = F}
install.packages(c(
  'shiny',
  'shinydashboard',
  'tidyverse',
  'lubridate',
  'DT',
  'pool'
))
```

## 4 crudr functions

There are really only 4 crudr functions you need to know:
**`cdr_make_db_tbls()`**, **`cdr_manage_db_tbls()`**,
**`cdr_deliver_admin_tbl()`**, & **`cdr_deliver_chg_log_tbl()`**.

### 1) cdr_make_db_tbls()

This function writes two tables into your database. You hand this
function a tibble and a pool connection, and it'll write that table, as
well as a corresponding change tracking table, into your database. If
you already have the main table in your database, no problem. Run the
same function with the same inputs and `cdr_make_db_tbls()` will just
create the change tracking table. If you already have both tables, the
function doesn't do anything except write some notes out to your R
console saying that it's not going to mess with tables that already
exist.

Note: For crudr to work, each row of the table you write must have a
Unique ID that's recorded as a character. If you don't have a Unique ID
key field in your table when , `cdr_make_db_tbls()` initially writes the
table, then the function will automatically make one for you named
"UID".

##### Example for cdr_make_db_tbls():

If you want to create a database on your machine called 'test.db', and
you want to put in a table called 'iris', you'd write:

```{r sqlite-db, eval = F}
con <- pool::dbPool(DBI::dbConnect(RSQLite::SQLite(), 'test.db'))
```

Then you'd call the function with the above connection and a table to
write.

```{r create-tbls, eval = F}
cdr_make_db_tbls(con, iris)
```

This code will join the new column, 'UID', onto your `iris` data and
push the table to your test database.

If you already created a Unique ID key field in your table, just tell
the function the name of that field with
`cdr_make_db_tbls(con, iris, key_field = 'name_of_your_unique_id_field')`.

Okay, the function should have written to your database a table called
'iris' and a second table called 'iris_DELTAS'. The table names are case
sensitive. You can see the tables that the function wrote by running the
following:

```{r eval = F}
paste(pool::dbListTables(con), collapse = ', ')
```

You should see the printout: "iris" and "iris_DELTAS". These two tables
are your original table with a 'UID' field and a secondary table named
like your first, but with '\*\_DELTAS'. The 'iris_DELTAS' deltas table
is a change log. Any change you make to the primary table through the
admin user interface, which we'll create below, gets recorded in the
deltas table.

As a side note, if you want to remove the tables later, you can that
with:

```{r eval = F}
pool::dbRemoveTable(con,'iris')
pool::dbRemoveTable(con,'iris_DELTAS')
```

Or, just delete the database 'test.db'.

### 2) cdr_manage_db_tbls()

This function is the workhorse of the package. If you remember one
function, this is the one. The function only has a handful of arguments.
At a minimum, you have to tell this function:

1.  What the name of your table is. In our example case it's,
    *db_tbl_name = 'iris'*.
2.  The field with your Unique ID. In our example case it's *key_col =
    'UID'*.
3.  What the database connection is. In our example case it's,
    *conn_pool = con*.

That's about it. There are other arguments you can change if you want to
control who can update things in the primary (admin) table, but you can
just 'F1' to get the function for that.

So, `cdr_manage_db_tbls()` returns 1 table directly and 2 tables
invisibly.

The direct table output in the example app below is: `iris_r_tbl`

The main R table is an output of the functions, as in
`iris_r_tbl <- dr_manage_db_tbls()`. Because it's a reactive table, you
use the table by acting like it's a function, but otherwise you treat it
like a table. So, if you wanted to select some columns or filter some
rows, you'd write,
`iris_r_tbl() %>% select(some_columns) %>% filter(some_rows)`, just like
with any other table object.

The `iris_r_tbl()` table is yours; you can do whatever you want with it.
You can send it out in any format you like, change the column names,
filter it, join it to something else...whatever. It's an output for the
masses.

## The 2 Invisible Tables

However, the 2 tables that `cdr_manage_db_tbls()` returns invisibly. You
pick these up with functions `cdr_deliver_admin_tbl()` &
`cdr_deliver_chg_log_tbl()`. The tables these functions return are not
like the direct output table. Rather, these tables are direct
representations of what's in your database.

### 3) cdr_deliver_admin_tbl()

This function picks up your invisible administrator table already
rendered in a DT object. The table is the primary database table that
you wrote into your test database when you ran `cdr_make_db_tbls()`, so
in our test case, `cdr_deliver_admin_tbl('iris')` will deliver 'iris'
data for a data curator. That is, whoever maintains your primary dataset
should have access to this admin table, and that person can make changes
to the data held in the database via this output in Shiny. This function
gets called in the UI portion of Shiny. A full example is below in the
section named CRUDR Example.

### 4) cdr_deliver_chg_log_tbl()

This function picks up your invisible history-of-changes table already
rendered in a DT object. This table is the '\*\_DELTAS' database table
that you wrote into your test database when you ran
`cdr_make_db_tbls()`, so in our test case,
`cdr_deliver_chg_log_tbl('iris')` will deliver a change history about
changes that your data curators made to the table 'iris'. That is, every
change that someone makes to your primary dataset gets recorded to this
admin table. You don't need to do much with this table. It's just there
to record which administrator did what to the database table, and when
they made the change. This function gets called in the UI portion of
Shiny. A full example is below in the section named CRUDR Example. This
table should be empty right now, but let's change that. Let's launch the
Shiny app.

## 

# A Tiny Shiny App

To manage the database tables, now let's launch a bare-bones shiny app.
We'll only need the 'crudr' functions described above. The other stuff
comes from packages *shiny*, *shinydashboard*, and *DT*.

Here's the code for your app. Copy it into your RStudio console and run
it.

## CRUDR Example

```{r tiny_crudr_app, eval = F}

con <- pool::dbPool(DBI::dbConnect(RSQLite::SQLite(), 'test.db'))

crudr::cdr_make_db_tbls(con, iris)

header <- shinydashboard::dashboardHeader(title = 'Tiny CRUDR Example')

sidebar <- shinydashboard::dashboardSidebar(
  shinydashboard::sidebarMenu(
    id = 'tabs',
    shinydashboard::menuItem(
      text = "Iris Data",
      startExpanded = TRUE,
      shinydashboard::menuSubItem("Administrator Table", tabName = "datr_editable", icon = shiny::icon('edit')),
      shinydashboard::menuSubItem("Change Log", tabName = "datr_change_log"),
      shinydashboard::menuSubItem("Iris End User View", tabName = "datr_end_usr")
    )))

body <- shinydashboard::dashboardBody(
  shinydashboard::tabItems(
    shinydashboard::tabItem(tabName = "datr_editable", crudr::cdr_deliver_admin_tbl('iris')),
    shinydashboard::tabItem(tabName = "datr_change_log", crudr::cdr_deliver_chg_log_tbl('iris')),
    shinydashboard::tabItem(tabName = "datr_end_usr", DT::DTOutput('iris_db_data'))
  ))

ui <- shinydashboard::dashboardPage(header, sidebar, body)



server <- function(input, output, session){


  iris_r_tbl <- crudr::cdr_manage_db_tbls(
   db_tbl_name = 'iris',
    key_col = 'UID',
    conn_pool = con,
    session = session,
    add_row_permission = T,
    del_row_permission = T,
    cell_edit_permission = T,
    lock_fields = c()
  )

  output$iris_db_data <- DT::renderDT(
    DT::formatDate(table   = DT::datatable(iris_r_tbl()),
                   columns = c('WHEN_EDITED_LAST'),
                   method  = 'toLocaleString')
  )


}


shiny::shinyApp(ui, server)

```

## 

# Make Some Changes

In the app above, you're the admin. So, go ahead and make changes in
this administrator table. Double-click on a cell in change the data.
Your app will write your change to the database, update the change log
table data, writes the change log data to the database, and then wait
for your next change. The 'Iris End User View' corresponds to the
`iris_r_tbl()` output from the server. Make your user output awesome,
like maybe add a download button to your output view by dropping in the
datatable code:

```{r DT_extension_example, eval = F}
DT::datatable(iris_r_tbl(), 
              extensions = 'Buttons', 
              options = list(dom = 'tB', buttons = c('copy', 'csv', 'excel','pdf')))
```

That's pretty much it. Close down the app. Then reopen it by running the
same app code again. The app should load the data from the database and
all the changes that you made to the data should be there.

## User Control Changes

If you want to set admin permissions for specific people, you can do so
in your shiny server with something like:

```{r user_control, eval = F}

user <- ifelse(is.null(session$user), Sys.info()[['user']], session$user)

if (user == 'your.name'){
  okay_to_change = T
} else {
  okay_to_change = F
}

```

Then pass 'okay_to_change into the `cdr_manage_db_tbls()` permission
argument(s). That makes the admin table just another table when a
typical user opens it, but you get to change it all you like as long as
you're the user called 'your.name'.

## Other Useful Info

For a Postgres database connection, use `RPostgreSQL::PostgreSQL()` as
the driver, since that's what I tested crudr on. Example Postgres
connection below.

```{r postgres_connection, eval = F}
con = pool::dbPool(
           DBI::dbConnect( RPostgreSQL::PostgreSQL(),
                           dbname = "test",
                           host = "localhost",
                           port = "5432",
                           user = your_dsn_uid,
                           password = your_dsn_pwd
                           ))
```

To close your database connection, run: `pool::poolClose(con)`

## Future Improvements

There are quite a few things I need to do to make this better. Maybe
I'll get to these sometime. Depends on whether anyone uses the app.

1.  Support for more databases, like sqlserver, oracle, etc. (I don't
    think it'd be that hard, I just need a test connection. If anyone
    knows how to make a free test connection to another database that I
    haven't yet supported, let me know.)

2.  When 2 or more admin users are making concurrent changes, update
    just the specific elements that the other person changed rather than
    refreshing the entire tables.

3.  At some point I should create a function,
    cdr_reconstruct_tbl_as_of(date = Sys.Date - 1, ignore_fields = c()),
    where you hand a date or datetime to the function and the function
    returns a tibble of the database as it was as of a particular point
    in time.

4.  Figure out how to push data to the database asynchronously so the
    user never has to wait for the data trips to the database.

5.  Figure out how to write automatic tests for the functions, then
    write a bunch of tests.

6.  Figure out package exports so I'm not exporting every single
    function.

7.  Interact with someone who knows how to simplify my code, and make it
    more readable.
